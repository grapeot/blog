Title: From Object Oriented Programming to Comment Oriented Programming -- Effective AI Assisted Programming
Date: 2024-03-17 17:00
Category: Computing
Tags: AI, Machine Learning, Programming
Slug: ai-comment-oriented-programming-en

Anyone who has seriously used AI for programming can attest to the profound impact it has had on our efficiency, effectiveness, and methodology in coding. Whether it's GPT-4, Claude V3, or Copilot, these tools have revolutionized how we approach programming tasks. Most real-world programs rely on relatively straightforward data structures and algorithms, making it possible for humans to program with the assistance of Stack Overflow, and for AI to easily handle with its vast training data. However, this article isn't about ringing the death knell for programming or stirring up anxiety about AI replacing humans. Rather, it's a reflection on how we can leverage this new tool to significantly enhance our productivity and outcomes.

While utilizing AI seems straightforward—just paste in the code or ask it to perform a task—the effective use of any new tool requires a period of exploration, consolidation, and thoughtful consideration, complete with its own set of tricks. This is especially true for a groundbreaking tool like AI. If we continue to view it through the lens of our old paradigms, we're likely to miss out on optimizing its potential. By setting aside my prior programming education and experience to embrace AI from a fresh perspective, I stumbled upon an unexpected insight: In the era of AI-assisted programming, our core product may no longer be code, but rather comments.

Let's focus on the typical training of a computer science talent. Data structures and algorithms are the bedrock of traditional computer science education. During undergraduate studies, we spend a whole year learning various data structures and algorithms, followed by specialized courses that delve into the unique data structures and algorithms required in each field, such as exponential backoff in computer networks or process trees in operating systems. Job preparation heavily emphasizes data structures and algorithms problems, like those on Leetcode. Once employed, our brains are constantly engaged in managing numerous variable states and devising algorithms for their interconversion. We take pride in our deep understanding of data structures, instinctively knowing which to use for speed or space efficiency. We are adept at analyzing time complexity, quickly deconstructing requirements into the most efficient code. Both our learning and working processes are deeply centered around data structures and algorithms. In fact, the cornerstone of modern programming—object-oriented programming—emphasizes the encapsulation of data structures (fields) and algorithms (methods).

However, after using AI programming tools like GPT and Copilot for a while, my realization is that the core of effective AI programming no longer revolves around data structures and algorithms. Even if I'm unsure of the optimal data structure for a given situation, it's okay; AI can suggest different options, analyze their pros and cons, and guide me to choose the most suitable one based on the context. If I'm uncertain about the best algorithm, no problem; AI can inform me about applicable libraries, the time complexity of each related library function. In the worst-case scenario, AI can even write the code directly for me. I just need to run it on actual data to select the most suitable algorithm. This entire process of coding and experimentation can be even faster than manually analyzing time complexity. From another perspective, even if I'm unfamiliar with the details of library functions and can't recall the significance of each parameter, AI can effortlessly provide hints and complete each parameter in function calls.

Therefore, the level of coding is not that important anymore when it comes to writing excellent code. This statement might sound odd, but what I mean is, consider two individuals: one who has mastered various data structures and algorithms, and another with just a basic understanding. In the traditional era of programming, the former would produce code of much higher quality and at a faster pace than the latter. However, in the age of AI-assisted programming, the difference between these two individuals in their ability to effectively and efficiently produce code with AI's help is often not that significant.

Contrarily, I've found AI to be particularly helpful in my development work when I take the time to write detailed comments. For Python, this means providing detailed Docstrings (Docstrings refer to detailed comments on function interfaces and parameters). This is because Docstrings, or similar comments, can describe a function's interface with precision and detail, allowing AI to accurately generate the correct code based on this information. For instance, if we mention in the AI's prompt something like "You can use this function `def extract_fwhm(self, image, verbose)`", based on that information alone, AI might struggle to write the code due to the potential ambiguities, such as what exactly the format of `image` should be, making the probability of AI getting it right in one go almost nil.

However, if we were to describe it in a detailed manner, with Typing Hints and Docstrings:
``` python
def extract_fwhm(self, img_data: npt.ArrayLike, verbose: bool = False) -> float:
        """
        Extract the FWHM of the given image.
        Note this function assumes that the input image has been debayered if it is a color image.
        Args:
            - img_data (npt.ArrayLike): The image to extract the FWHM from.
            - verbose (bool): Whether to print the progress of the extraction.
        Returns:
            The FWHM of the given image.
        """
```

AI could easily get it right in one attempt. Thus, if two people were competing in coding, and one meticulously wrote Typing Hints and Docstrings, including them in the prompt, while the other adhered to the traditional method, emphasizing code quality but neglecting the quality of comments, the former would be much more efficient (and possibly more accurate). This holds true even if the latter is traditionally considered a coding expert. This is why I believe that in the new era of AI-assisted programming, the focus of programming output has shifted from being code-centric to comment-centric. The quality and efficiency of the code produced are directly determined by the quality of the comments. In other words, if object-oriented programming implicitly encapsulated the core of traditional programming—data structures and algorithms—comment-oriented programming is the key to efficiently utilizing AI-assisted programming.

This observation is quite fascinating. A simple extension is that if we consider the issue from a slightly more abstract perspective, the purpose of writing comments is to ensure that the questions we pose to AI are self-consistent and within the realm of what AI has enough information and capability to solve. In other words, to efficiently utilize AI, we cannot mindlessly toss every problem its way, but must constantly question: Is the issue properly defined? Does AI possess sufficient information to complete the task? Can we reasonably expect a person or AI to accurately implement this task? Interestingly, these are the exact questions a Software Development Manager (SDM) contemplates daily.

Following this line of thought and combining it with actual experience using AI in programming, I believe that the most crucial qualities needed for efficient AI programming are essentially the core qualities of a development manager:

1. **Understanding Your Charge**: Know the limits of their capabilities, such as understanding the context window, the concept of hallucination, and its scenarios for AI. Also, know how to motivate your charge, like incentivizing people with promises of rewards or PIPs, and perhaps even "tipping" AI in some way.
2. **Deciding When and What to Delegate**: Based on the capabilities of your charge, decide which tasks you need to handle personally and which you can confidently delegate, entrusting them to your subordinates.
3. **How to Delegate**: Break down problems into manageable chunks that fit the capabilities of your subordinates and let them tackle these pieces. For AI, given its limited context window, long prompts often lead to forgetting or cutting corners. So, if we can decompose a problem into chunks suited to the context window and step-by-step guide AI, we can significantly enhance the success rate and quality of coding.
4. **Quality Checks**: How to evaluate AI's output to ensure code quality, especially avoiding the impact of hallucinations. This could involve using automated or manual testing, which itself can be AI-assisted.
5. **Learning from Your Charge**: A major source of knowledge updating for human development managers comes from learning from their subordinates. There's no shame in this, as a manager is not expected to be more technical than the subordinates specializing in coding. For ordinary programmers managing AI, AI also serves as an excellent learning tool.

In the new era of AI-assisted programming, these managerial skills transform from merely overseeing human teams to effectively guiding AI processes, highlighting a fascinating blend of technology and traditional management wisdom.

So, does the future hold a shift where everyone becomes a development manager in this age of AI-assisted programming, rendering the coder's role obsolete? I'm quite optimistic about this. That's because the core competitiveness of a software engineer has never been about how fast they can code or how well they've mastered data structures and algorithms. A senior software engineer's promotion isn't because they have memorized libraries more thoroughly or can manually invert a red-black tree, but because they make design decisions. Letting a newcomer to the field make these decisions could likely lead to errors that no amount of speedy coding can rectify. Similarly, the reason why a staff engineer is promoted to staff isn't because they code faster than a senior or know more complex algorithms but because they can identify critical issues that others overlook and convince everyone of their importance. From this perspective, the advent of AI actually raises the ceiling of programming rather than replacing the software engineer profession.

However, AI indeed brings profound changes. It shifts the focus of programming skills from traditional proficiency in data structures and algorithms to capabilities more valued by development managers, such as understanding the limits of AI's abilities and breaking down problems into manageable pieces for AI to solve. History has seen similar shifts before. For instance, before calculators were invented, school education heavily emphasized proficiency in arithmetic operations, even to the extent of fostering complex and innovative techniques like abacus arithmetic. Yet, with the advent of calculators, abacus arithmetic gradually disappeared from the curriculum, and our speed and accuracy in arithmetic operations significantly improved. On the other hand, professions reliant on arithmetic operations didn't vanish; their ceilings were elevated instead. Thus, while AI-assisted programming is a fundamental and revolutionary change, making some skills more crucial and others less so, there's no need to hastily declare the profession of software engineering extinct.

It's the best of times, and it's the worst of times. The era of AI-assisted programming impacts different people in different ways. But one thing is for sure: it's a time of change. Even this article itself may become outdated with the emergence of new AI technologies. The constant, however, is that as long as we continue to think and stay passionate, I remain optimistic that with the help of smarter and more user-friendly tools, our competitiveness can be multiplied again and again.