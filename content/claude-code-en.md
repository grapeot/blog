Title: The Underestimated Claude Code: A Key Puzzle Piece for AI Native Software Development
Date: 2025-02-24 19:30
Category: Computing
Tags: Claude Code, AI Native, Agentic AI, English
Slug: claude-code-en

Anthropic recently released Claude 3.7, attracting widespread media attention. However, most people seem to have overlooked another tool launched simultaneously—Claude Code. This command-line tool appears less impressive, with an interface that isn't particularly user-friendly, and it doesn't make bold claims about self-evolution or replacing human programmers like Cursor or Devin. But after diving deeper, I realized that this seemingly ordinary tool might be the key to driving the AI Native software development revolution, and could even profoundly influence future business models and ecosystems.

## From Traditional Patterns to AI Friendly Development

In our process of introducing and promoting Agentic AI, we often receive feedback about AI programming tools like Cursor: these tools can perform well for rapid prototyping, helping write scripts, or performing ad-hoc data analysis tasks. However, when it comes to large projects or established mature codebases, AI frequently gets stuck—it often can't find the most relevant files and function interfaces, doesn't understand the related development standards and best practices, let alone comprehend the high-level decision-making process for each design or its historical baggage.

But this is actually a critical issue. Many enterprises have internal core codebases of hundreds of thousands or even millions of lines of code. Just listing the dependencies, structure, and documentation is overwhelming enough for humans, let alone expecting AI to learn it all at once. As a result, AI excels in small projects but struggles with enterprises' most critical systems. If we can't solve the problem of connecting with existing codebases, AI development will remain limited to auxiliary development or prototype construction, rather than being used in large, serious, and commercially valuable projects. If we can solve the problem of helping AI correctly and efficiently use existing codebases, the entire field's development could progress rapidly. We could see AI-driven software development quickly implemented across various domains. In some ways, AI development is facing a chasm—on one side is the beautiful vision of AI autonomously developing software, and on the other is the reality that AI still can't effectively utilize most private codebases.

To be fair, this isn't really AI's fault. As we've [discussed multiple times before](https://yage.ai/prompt-engineering-guide-en.html), for AI to effectively complete any task (not just programming), it needs sufficient background knowledge. It's like hiring a new intern—if you simply hand them a codebase with hundreds of files and expect them to immediately write correct and efficient code, you're being unreasonable. A better approach is to provide onboarding training so they understand the library's functions, structure, design, and even history. With such training, the intern's success rate in writing quality code increases dramatically.

For AI, this onboarding training often takes the form of a ready-made prompt file. For example, the Model Context Protocol (MCP) project provides such a prompt file at [this URL](https://modelcontextprotocol.io/llms-full.txt). If you give this prompt file to an AI (like ChatGPT or Cursor), it will have enough background knowledge to write correct code. Currently, building these prompt files is still largely a semi-automatic or even manual process. For instance, we can take all the docstrings of functions in a library, give them to ChatGPT, and ask it to filter out the most important functions and write a Markdown document to use as an AI prompt. With this documentation support, AI can easily write correct programs for small to medium-sized projects.

So, up to this point, we've seen two different software development models. The traditional model delivers just the code itself, perhaps with human-readable documentation. But a new approach is AI-friendly software development. It emphasizes that software development deliverables aren't just for humans but also for AI. So, in addition to the code itself and human-targeted documentation, it often includes an AI-specific prompt file. The benefit is that AI can quickly get up to speed and write correct programs using the library.

As tools like Cursor become increasingly popular, the importance of AI-friendly software development is growing. For example, if you're a company's technical leader choosing between two libraries, and one can be used immediately with Cursor to write programs while the other requires various learning and processing before you can gradually write with AI assistance, the former has an undeniable competitive advantage in the market.

## 21st.dev, Library as a Service, and AI Native Development

The AI-friendly software development model, while a significant improvement over traditional software development, is still quite far from revolutionizing the entire software development field. To understand this, let's look at the [21st.dev](https://21st.dev/) website. This website, or library, is quite interesting. It's essentially a UI library that provides many frontend components. But unlike traditional software libraries, it doesn't deliver all the components to users for them to write code. Instead, it reverses the process—users tell it what they want to build, and it selects and calls the appropriate UI components to build a frontend for the user. In other words, its deliverable isn't a class library but the code that users need, which includes relevant classes that users can modify afterward.

This is actually a new way of using libraries: Library as a Service (LaaS). The deliverable of a software library isn't code or documentation, but directly becomes a service, an API. For the user experience, this is a significant change. Even with AI-friendly models, developers still need to write and maintain prompt files themselves, placing many demands on teams in terms of document management, version control, and prompt writing. Therefore, even the AI-friendly development model often only makes local improvements to the existing code-package-deploy pipeline, without fundamentally changing the delivery model. LaaS is different—it starts from the logic of "I'm delivering an API + the AI execution power behind it," bundling business and technical delivery together, completely changing how to charge, demonstrate, and iterate. If traditional software libraries deliver building materials, LaaS delivers a construction team that includes both labor and materials, restructuring the software development value chain.

Beyond upgrading the user experience, LaaS also offers significant benefits to library-providing enterprises. On one hand, it gives companies greater control and autonomy—externally encouraging users to apply best practices when using the library, and internally enabling more comprehensive and efficient optimizations. On the other hand, from a charging perspective, this added-value service can bring excess profits, turning traditional one-time-delivery software libraries into continuous sources of income.

For the entire software development field, the LaaS method brings enormous potential. If future software libraries are all delivered using the LaaS method, the process of AI using these libraries to further build software will become particularly simple and smooth. AI will play more of a planner role, only needing to decide which library to use for which problem based on each library's expertise. Then, AI can use each library's service through API calls to write specific code. In a sense, this can also be called Library as an Agent. This transforms the complex process of developing software using multiple libraries into a problem of multi-agent cooperation and iteration. This solves the problem we raised at the beginning of the previous chapter. With LaaS, by completely delegating library learning and usage to agents built by library authors, Agentic AI is no longer just a toy for solving ad-hoc problems but can flexibly and efficiently adapt to existing enterprise-level software libraries.

This development method is more AI-native compared to traditional methods or even AI-friendly methods. Although Agentic AI is still very new, and it's difficult to predict what form software development will ultimately converge to, we can be fairly certain that the method everyone will adopt will be AI-native—where all technical means are designed around AI, serving as AI enablers to maximize AI's work efficiency.

## Claude Code and the Future AI Development Ecosystem

While the LaaS vision is promising, implementing it still has high barriers. For instance, how to introduce Agentic Workflow into the code generation process to achieve self-iteration and self-correction, thereby ensuring the quality of generated code. This requires considerable practical experience and a deep understanding of LLMs. We only need to look at the performance gap between open-source Cline and Cursor to understand this.

But the emergence of Claude Code fills this gap, greatly reducing the difficulty of implementing LaaS. Specifically, Claude Code provides functionality similar to a command-line version of Cursor. By describing the programming task in natural language through command-line parameters, it calls several accompanying tools, including running commands and modifying files, to use Agentic Workflow to achieve self-iteration and self-correction. Therefore, many application scenarios that were previously difficult to solve because Cursor doesn't provide an API can now be easily implemented with the help of Claude Code.

So although it doesn't have a GUI and doesn't seem particularly attractive to end users, Claude Code, as a fundamental building block, provides a solid foundation for constructing many similar applications. At the same time, guided by the LaaS vision, its value isn't in allowing us to quickly copy Cursor, but in its potential to push the entire software development field toward LaaS or similar AI-Native development paradigms. This completes an important puzzle piece for fundamentally changing the entire AI development model.

Beyond this, Claude Code has another function: it can use an Agentic approach to call various tools to read code in a folder and build a prompt file step by step. Its Agentic characteristics allow it to actively explore the codebase and continuously improve and correct its understanding of the project through dynamic analysis of the execution process. It's like a human intern who, after receiving initial instructions, reads and analyzes relevant modules on their own, using a combination of natural language descriptions and tool calls to confirm which parts of the code are suitable for reuse and which need to be rewritten. Once we complete this migration process in existing systems, it's equivalent to truly breaking down the barriers between AI and traditional codebases. When subsequently developing new features or refactoring old logic, AI doesn't need to go through the same lengthy learning process again, but can directly take over this automated workflow and iteratively update the results.

Therefore, overall, Claude Code's goal is to transform the traditional use of software libraries toward AI-Friendly and AI-Native directions, by providing appropriate tools to make these two migrations smoother and painless. The vision and ambition behind it are actually far greater than the surface value of this simple command-line tool. The embryonic form of a world where AI coordinates all services, automates coding, and automates scheduling may have already quietly appeared in Claude Code. This vision still has a long way to go before it truly lands, including standardization of API specifications, security policy controls, and discussions on the boundaries and responsibilities of Agentic AI in different scenarios. But judging from the step Claude Code has taken, Anthropic is already very pragmatically solving an industry-wide pain point: how to make AI more intelligently interface with old systems, and how to make old systems gradually transform into the new LaaS form, thus heading toward an AI-native future.

Perhaps this is Anthropic's most forward-looking aspect, yet it has been overlooked by many because it's not as flashy as Claude 3.7. But I believe that when people look back in the future, they'll find that Claude Code played an irreplaceable starting role in this AI-native software revolution.
